ğŸ‘‹ 20 - URLHelpers - HTMLHelpers FonksiyonlarÄ±

YardÄ±mcÄ± metotlarÄ±mÄ±z olan helpers'larÄ± inceleyeceÄŸiz. Helpers yapÄ±lanmasÄ± ASP.NET Core MVC'de UrlHelper, HtmlHelper, ve TagHelper olarak Ã¼Ã§e ayrÄ±lÄ±r.

ğŸ‘‰ ! Neye Yarar Bunlar?


Helpers yapÄ±lanmalarÄ±, adÄ± Ã¼zerinde yardÄ±mcÄ± metotlardÄ±r.

ğŸ‘‰ ! UrlHelper:


URL ile ilgili iÅŸlemler yaparken manuel olarak uÄŸraÅŸmak yerine hÄ±zlÄ± bir ÅŸekilde bu iÅŸlemleri, rotalara uygun URL oluÅŸturma gibi durumlarda saÄŸlar.

ğŸ‘‰ ! HtmlHelper:


HTML ile ilgili Ã§alÄ±ÅŸmalarda yardÄ±mcÄ± metotlar tanÄ±mlamaktadÄ±r.

ğŸ‘‰ ! TagHelper:


HTML etiketleri ile ilgili ekstra yardÄ±mcÄ± olan bir helper'dÄ±r.


ğŸ‘‰ ! UrlHelper ve HtmlHelper, ASP.NET standart framework ile gelen helper'lardÄ±r.

ğŸ‘‰ ! TagHelper ise ASP.NET Core mimarisinde eklenmiÅŸtir.

âœ¨ UrlHelper âœ¨


ASP.NET Core MVC uygulamalarÄ±nda URL oluÅŸturmak iÃ§in yardÄ±mcÄ± metotlar iÃ§eren ve o anki URL'ye dair bizlere bilgi veren bir sÄ±nÄ±ftÄ±r. Metotlar ve property'ler ise ÅŸu ÅŸekildedir:

![20-1](https://github.com/user-attachments/assets/20c8455b-ca9a-4db8-9466-e71208620e3f)


âœ¨ Action Metodu âœ¨


Verilen controller ve action'a ait URL oluÅŸturmayÄ± saÄŸlayan metottur. Manuel olarak da link oluÅŸturabilirsiniz, ancak Action metodu ile daha pratik bir ÅŸekilde oluÅŸturulabilir.

ğŸ‘‰ ! Controller veya View dosyalarÄ±nda URL helper'a eriÅŸmek istiyorsanÄ±z Url propertyâ€™sini kullanmanÄ±z yeterlidir.

ğŸ‘‰ ! Base class'tan geldiÄŸi iÃ§in ayrÄ±ca tanÄ±mlama yapmanÄ±za gerek yoktur.


![20-2](https://github.com/user-attachments/assets/cb8dab20-cb48-44fe-a6d4-06c26e9c560c)

Hedef controller Product, hedef action Index ise ve varsa parametre tanÄ±mlamalarÄ± new { id = 5 } ÅŸeklinde verilebilir.
Ã‡Ä±ktÄ± olarak bize bir URL oluÅŸturur.

ğŸ‘‰ ! Action metodu, oluÅŸturulacak URLâ€™in ana dizinini oluÅŸturmaz. Yani host bilgisi, port bilgisi ve protokol bilgisini vermez; sadece URLâ€™in devamÄ±nÄ± oluÅŸturur.

ASP.NET Core MVC ve Rotalar:

Rotalar, Startup.cs iÃ§inde UseEndpoints middleware'inde tanÄ±mlanÄ±r.
RotalarÄ±n yapÄ±sÄ±na uygun olarak Action metodu bize URL Ã¼retir.
Middleware'de controller ve action sÄ±ralamasÄ± nasÄ±l tanÄ±mlandÄ±ysa URL de buna gÃ¶re ÅŸekillenir.

ASP.NET Core MVC uygulamalarÄ±nda rotalar Startup.cs dosyasÄ±ndaki UseEndpoints middleware'i iÃ§inde tanÄ±mlanÄ±r. Buradaki rotalara uygun olarak action metotlarÄ± Ã§Ä±ktÄ± Ã¼retir ve URL oluÅŸturur.
UseEndpoints middleware'inde controller ve action sÄ±ralamasÄ± nasÄ±l belirlenmiÅŸse, URL de buna gÃ¶re ÅŸekillenir.


ğŸ‘‰ !  MapControllerRoute: KullanÄ±cÄ±nÄ±n kendi isteÄŸine gÃ¶re Ã¶zelleÅŸtirebileceÄŸi ve tanÄ±mlayabileceÄŸi rota ÅŸablonudur.

ğŸ‘‰ !  MapDefaultControllerRoute: Sistemin varsayÄ±lan olarak kabul ettiÄŸi, Ã¶nceden tanÄ±mlanmÄ±ÅŸ bir rota ÅŸablonudur.

"app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");
});
" 
Bu yapÄ±, varsayÄ±lan olarak Home controller'Ä±ndaki Index action metodu ile baÅŸlar ve id parametresi opsiyoneldir.


âœ¨  ActionLink Metodu âœ¨


ActionLink, belirli bir controller ve action iÃ§in URL oluÅŸturmayÄ± saÄŸlayan bir metottur. Action metoduna benzer ÅŸekilde Ã§alÄ±ÅŸÄ±r, ancak Ã§Ä±ktÄ±sÄ± farklÄ±dÄ±r. Burada protokol, host ve port bilgisi de yer alÄ±r.

![20-3](https://github.com/user-attachments/assets/2b9f7279-ade9-4ad8-8306-e95f01c5e82e)

@Html.ActionLink("Anasayfa", "Index", "Home")

Ã§Ä±ktÄ±sÄ± : https://localhost:5001/Home/Index


âœ¨ Content Metodu âœ¨


Statik dosyalar (Ã¶rneÄŸin CSS, JavaScript veya resim dosyalarÄ±) iÃ§in proje iÃ§erisindeki dizinlere gÃ¶re URL oluÅŸturur.

![20-4](https://github.com/user-attachments/assets/fbde769b-e1cd-4951-95d4-8568394f2767)

<img src="@Url.Content("~/images/logo.png")" alt="Logo">

Ã§Ä±ktÄ±sÄ± : /images/logo.png

âœ¨ RouteUrl Metodu âœ¨

Mimaride tanÄ±mlÄ± olan rota isimlerine uygun ÅŸekilde URL oluÅŸturan bir metottur. MapControllerRoute ile istediÄŸimiz gibi rotalar oluÅŸturabiliyorduk ve dikkat edilirse bu rotalarÄ±n isimleri vardÄ±r.

![20-5](https://github.com/user-attachments/assets/5f4bf98c-988c-49d1-a50e-25454a51d5d2)

![20-6](https://github.com/user-attachments/assets/32701089-3c42-4430-87ad-96db420872e3)

Birden fazla rota olduÄŸunda, isim belirterek uygun URL oluÅŸturulabilir.

âœ¨ ActionContext Ã–zelliÄŸi/Property âœ¨


O anki URL'ye dair tÃ¼m bilgilere eriÅŸmemizi saÄŸlayan bir Ã¶zelliktir. Gelen isteÄŸe dair bize bilgi veren bu property ile URL, controller, action gibi bilgileri elde edebiliriz.

![20-7](https://github.com/user-attachments/assets/3332d0c3-88dc-40da-8a4b-36efbedb1bcf)

âœ¨ HTML Helper âœ¨


Hem maliyetli hem de performanslÄ± yapÄ±lanmalardÄ±r. TagHelper'lar ise daha az maliyetli ve daha performanslÄ± yapÄ±lardÄ±r.

HTML etiketlerini server tabanlÄ± oluÅŸturmamÄ±zÄ± saÄŸlayan sÃ¶zde yardÄ±mcÄ± metotlarÄ± barÄ±ndÄ±rmaktadÄ±r. SÃ¶zde yardÄ±mcÄ± metot denmesinin sebebi, gereksiz yere servera yÃ¼k bindirmesidir.

Hedeflenen .cshtml dosyalarÄ±nÄ± render etmemizi saÄŸlar.
O anki baÄŸlama (context) dair bilgiler edinmemizi saÄŸlar.
Veri taÅŸÄ±ma kontrollerine eriÅŸmemizi saÄŸlar.

ğŸ‘‰ !  Metotlar ve Property'ler:

![20-8](https://github.com/user-attachments/assets/b916a9d2-f2b3-48ed-baf8-e7b3850a1a40)

Buradaki TempData, ViewData ve ViewBag; veri taÅŸÄ±ma kontrollerine eriÅŸebilmemiz iÃ§in view Ã¼zerinde ekstra bir ÅŸey tanÄ±mlamamÄ±za gerek kalmaz. HTML Helper Ã¼zerinden de eriÅŸim saÄŸlayabiliyoruz.

âœ¨ HTML Partial Metodu âœ¨


Hedef view'Ä± render etmemizi saÄŸlayan bir fonksiyondur.
Controller'dan gelen istek neticesinde render etmek zorunda deÄŸilsiniz. Bir view iÃ§erisindeyken belirli bir noktada Html.Partial ile hedef view'i Ã§aÄŸÄ±rÄ±p onu render edebilir ve Ã§Ä±ktÄ±sÄ±nÄ± o noktaya verebilirsiniz. Yani illa controller'dan istek gitmesine gerek yoktur.

![20-9](https://github.com/user-attachments/assets/a8288e4b-0138-423c-9b86-a52fef449dc0)



âœ¨ Render Edilen Viewâ€™e Model/Data GÃ¶nderme âœ¨


Render edilen view'e ilgili action'dan model/data gÃ¶nderilebilmektedir. Ã–rneÄŸin bir istek geldi ve A controller iÃ§indeki B action'Ä±ndasÄ±nÄ±z. B action'Ä±ndan B view'Ä±na gittiniz, B view'Ä±nda C view'Ä±nÄ± Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ±zÄ± dÃ¼ÅŸÃ¼nelim. C view'Ä±na data gÃ¶nderecekseniz A'dan B Ã¼zerinden data taÅŸÄ±manÄ±z gerekir. C'yi tetiklediÄŸiniz nokta B view'Ä±dÄ±r. B view'Ä±nda da partial Ã¼zerinden tetiklediÄŸiniz iÃ§in, eÄŸer bir model/data ihtiyacÄ± varsa bunu A Ã¼zerinden taÅŸÄ±manÄ±z gerekmektedir.


ğŸ‘‰ !  Ã–rnek:


Views altÄ±nda Partials klasÃ¶rÃ¼ altÄ±na ListPartial adÄ±nda bir view oluÅŸturuyorum. FarklÄ± bir view'e (GetProducts.cshtml) controller Ã¼zerinden render talebi geldiÄŸinde, ilgili view'i render ederken bir yandan da ListPartial.cshtml'i render etmek istiyorsam, GetProducts.cshtml'de partial'Ä±n dizinini de belirterek ÅŸu ÅŸekilde kullanÄ±rÄ±m: 

![20-10](https://github.com/user-attachments/assets/3c84714c-1826-45f2-97c2-9d78e1023a6d)


AynÄ± zamanda ListPartial'da belirli bir model/sÄ±nÄ±f kullanmak istersek bu veriyi nereden alacaÄŸÄ±m? Veriyi, hangi controller Ã¼zerinde tetikleme gerÃ§ekleÅŸtiriliyorsa (GetProducts'Ä± tetikleyen controller) oradan almam gerekir. Controller'dan view'e (GetProducts) taÅŸÄ±nan veri, GetProducts'ta kullanÄ±lan tÃ¼m partial view'lara da taÅŸÄ±nÄ±r.


ğŸ‘‰ !   Dikkat Edilmesi Gereken Noktalar:


EÄŸer GetProducts'a User adÄ±nda bir model gÃ¶nderecekseniz, bu normalde GetProducts.cshtml'deki partial view'e User adlÄ± model gider. Ancak GetProducts'ta User adÄ±nda bir model kullanÄ±p, GetProducts iÃ§indeki partial view'da farklÄ± bir model kullanmak/gÃ¶ndermek isterseniz, iÅŸte o zaman partial'Ä± Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ±z yerde 2. parametre olarak gÃ¶ndereceÄŸiniz modeli belirtmeniz gerekir.

![20-11](https://github.com/user-attachments/assets/89048fc9-533b-46a5-bb3d-f1e52743ba70)

Yada ilgili modeli oluÅŸturabilirsiniz.

![20-12](https://github.com/user-attachments/assets/26f3ec84-1e36-4978-b073-752a345f2f7a)


âœ¨ Html RenderPartial Metodu âœ¨

![20-13](https://github.com/user-attachments/assets/b6f2520c-0ef0-4da8-829d-02b93765fcde)

Partial, scope'a gerek kalmadan tek satÄ±rda Ã§aÄŸrÄ±labilirken, Html.RenderPartial ise scope iÃ§inde Ã§aÄŸrÄ±lmaktadÄ±r. Bunun sebebi, Partial geriye string dÃ¶ndÃ¼rÃ¼rken Html.RenderPartial void dÃ¶ndÃ¼rÃ¼yor/yani bir ÅŸey dÃ¶ndÃ¼rmÃ¼yor ve bunu da tetikleyebilmek iÃ§in scope iÃ§inde C# kurallarÄ± ile kullanmak gerekir.
Html.Partial'a gÃ¶re, Html.RenderPartial daha hÄ±zlÄ±dÄ±r.

âœ¨ Html ActionLink Metodu âœ¨

![20-14](https://github.com/user-attachments/assets/2a489599-442d-43f9-b1e4-e6a18704ab4b)

Hem Ã§Ä±ktÄ±yÄ± verir hem de linki oluÅŸturur.

âœ¨ Html Form MetotlarÄ± âœ¨

![20-15](https://github.com/user-attachments/assets/a45f7ea4-658b-4a5d-8fce-90d6d4550659)

Burada bir TextBox oluÅŸturmak bile sunucu taraflÄ± gerÃ§ekleÅŸeceÄŸi iÃ§in sunucuyu yorar/maliyetli olur. Bu maliyeti ortadan kaldÄ±rmak iÃ§in Tag Helper dediÄŸimiz yapÄ±lanmalar ortaya Ã§Ä±kmÄ±ÅŸtÄ±r.
ASP.NET Core MVC ile gelen Tag Helper yapÄ±lanmalarÄ±, Html Helper'lara gÃ¶re daha hÄ±zlÄ± ve daha efektiftir.


ğŸ‘‹ 21 - Custom HtmlHelper Fonksiyonu OluÅŸturma



Html helper'larÄ±n nasÄ±l customize edildiÄŸini, yani custom HtmlHelper oluÅŸturmayÄ± ele alacaÄŸÄ±z.
HtmlHelper'lar, HTML nesneleri oluÅŸtururken bize yardÄ±mcÄ± olan, hazÄ±r metotlarÄ±mÄ±zÄ± barÄ±ndÄ±ran bir kÃ¼tÃ¼phane/sÄ±nÄ±ftÄ±r. DolayÄ±sÄ±yla bu sÄ±nÄ±f Ã¼zerinden oluÅŸturduÄŸumuz HTML nesneleri, server tabanlÄ± olarak ilgili sayfayÄ± view'e basabiliyoruz. Bunun maliyeti ve performans zayÄ±flÄ±ÄŸÄ± vardÄ±r. EÄŸer HtmlHelper'larÄ± kullanÄ±yorsak, varsayÄ±lan Ã§Ä±ktÄ±larÄ± Ã¶zelleÅŸtirebiliyoruz.

![21-1](https://github.com/user-attachments/assets/140b1692-abda-4856-9a53-cbb9b89059cb)

HtmlHelper yapÄ±lanmasÄ±nda TextBox ya da kullandÄ±ÄŸÄ±nÄ±z helper fonksiyonu hangisi ise, diÄŸer overload'larÄ±na bakarsanÄ±z belirli farklÄ± parametreler aldÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼rsÃ¼nÃ¼z.

Biz TextBox nesnesi Ã¼zerinden Ã¶rneklendirme yaparken htmlAttribute ile HTML attributeleri verebiliyoruz. 4. overload'u kullanÄ±yoruz.
Attribute/Property'ye karÅŸÄ±lÄ±k deÄŸerler oluÅŸturulacak, yani generate edilecek olan HTML nesnesine, o input Ã§Ä±ktÄ±sÄ±na attribute/Ã¶zellik olarak eklenecektir.

![21-2](https://github.com/user-attachments/assets/c04619d7-fbd3-4b0c-b040-616355b23cb3)

![21-3](https://github.com/user-attachments/assets/e488bc9c-a966-40e9-9421-19bcde43e2c4)

Burada "a" verdiÄŸim attribute, Ã§Ä±ktÄ±ya value/attribute olarak eklenmiÅŸtir.

ğŸ‘‰ !   Biz her HTML nesnesi talep ettiÄŸimizde, talep ettiÄŸimiz anda bunun ayarlarÄ±nÄ± vermek zorunda mÄ±yÄ±z?


EÄŸer birÃ§ok noktada customize edilecek HTML formatlarÄ±na ihtiyaÃ§ varsa, biz custom bir ÅŸekilde sÄ±rf o iÅŸe odaklÄ± HTML nesnesi oluÅŸturabiliriz. NasÄ±l oluÅŸturacaÄŸÄ±z? Bir extension oluÅŸturarak yazacaÄŸÄ±z.

![21-4](https://github.com/user-attachments/assets/11fde0e9-5e21-46d9-943a-447011618349)

Extension metot yazmadan Ã¶nce, HtmlHelper'larÄ±mÄ±zÄ±n tÃ¼rÃ¼ne bakacaÄŸÄ±z. TextBox iÃ§in bize IHtmlContent olarak sonuÃ§ dÃ¶nÃ¼yor.
Demek ki benim customize edeceÄŸim extension fonksiyonunun da IHtmlContent dÃ¶ndÃ¼rmesi gerekiyor.

HtmlHelper Ã¼zerinde eriÅŸilebilir bir custom HtmlHelper oluÅŸturacaÄŸÄ±m iÃ§in, IHtmlHelperâ€™a Ã¶zel yazmam gerek. 

![21-5](https://github.com/user-attachments/assets/5bf6a255-28a6-442d-b7d9-ebc7691ecd26)

DolayÄ±sÄ±yla hangi tÃ¼rde bir extension oluÅŸturacaksam (IHtmlHelper), bu extension hangi tÃ¼rde sonuÃ§ dÃ¶necekse (IHtmlContent), bu bilgilere gÃ¶re artÄ±k rahatlÄ±kla extension oluÅŸturabileceÄŸiz.

BaÅŸka bir deyiÅŸle, custom HtmlHelper'Ä±mÄ± tasarlayabilirim.


âœ¨ Custom HTML Helper Tasarlama âœ¨


Proje altÄ±na Extensions adÄ±nda bir klasÃ¶r oluÅŸturuyorum ve iÃ§ine ismi Ã¶nemsiz olmaksÄ±zÄ±n herhangi bir sÄ±nÄ±f oluÅŸturuyorum (biz Extensions adÄ±nda sÄ±nÄ±f oluÅŸturacaÄŸÄ±z).
Extensions sÄ±nÄ±fÄ±nda extension metot tanÄ±mlayabilmem iÃ§in ilgili sÄ±nÄ±fÄ± static olarak iÅŸaretliyorum.

ArdÄ±ndan static extension fonksiyonumu tanÄ±mlÄ±yorum.
TextBox iÃ§in IHtmlContent dÃ¶neceÄŸinden, oluÅŸturacaÄŸÄ±m metoda ona gÃ¶re dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ veriyorum.
Bu metodu extension metot yapabilmemiz iÃ§in, IHtmlHelper tÃ¼rÃ¼nden bir this parametresi almasÄ± gerek.

![21-6](https://github.com/user-attachments/assets/1800ac03-47fd-4310-96db-b0e17ad1713f)

ArtÄ±k bu fonksiyon, mimarideki IHtmlHelper tÃ¼rlerine extension olarak eklenmiÅŸtir.

Hangi HTML Helper nesnesi Ã¼zerinde Ã§alÄ±ÅŸÄ±yorsak, metottaki parametre bana o nesneyi getiriyordu.
En son geriye de TextBoxâ€™Ä± dÃ¶ndÃ¼rÃ¼yoruz.

ğŸ‘‰ !  @class ile classâ€™Ä±n bir isim olduÄŸunu, keyword olmadÄ±ÄŸÄ±nÄ± belirttik.

Ä°lgili oluÅŸturduÄŸum custom TextBoxâ€™Ä± kullanmak istersem,
.cshtml dosyasÄ±nda ilgili extension fonksiyonunun bulunduÄŸu namespaceâ€™i using etmem gerek. 

![21-7](https://github.com/user-attachments/assets/9e05a097-5684-4905-8509-4cebe1acbe9f)

Ã–zetle, Bir ÅŸeyin custom halini oluÅŸturmak istiyorsan, extension fonksiyonlarÄ±nÄ± kullanabilirsin. Bir yapÄ±nÄ±n customize edilmiÅŸ halini extension ile Ã§ok rahat yapabilirsin.


ğŸ‘‹ 22 - TagHelpers


TagHelper'lar, HTML Helper'larÄ±n yerine gelen yeni yapÄ±lanmalardÄ±r. Peki, bunlar nedir?
TagHelper'lar, daha okunabilir, anlaÅŸÄ±labilir ve kolay geliÅŸtirilebilir bir view inÅŸa etmemizi saÄŸlayan, ASP.NET Core ile birlikte HTML Helper'larÄ±n yerine gelen bir yapÄ±lanmadÄ±r.



âœ¨ TagHelpers vs HTML Helpers âœ¨

![22-1](https://github.com/user-attachments/assets/8eb6c423-fd06-4d00-8d70-38e54dd23091)

![22-4](https://github.com/user-attachments/assets/b52e3500-3b6d-4ef1-9fc5-38600e75c34a)

âœ¨ TagHelper Entegrasyonu âœ¨


TagHelper'Ä± kullanabilmek iÃ§in Ã¶ncelikle view'lere belirli bir kÃ¼tÃ¼phaneyi entegre etmemiz gerekecek.
Bir view Ã¼zerinde TagHelper kullanacaksam, ilgili kÃ¼tÃ¼phaneyi view'e entegre etmeliyim.

ğŸ‘‰ ! @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers

ğŸ‘‰ ! TagHelper'lar Ã¶zÃ¼nde bir sÄ±nÄ±f olduklarÄ±ndan, belirli bir kÃ¼tÃ¼phaneyi iÃ§inde barÄ±ndÄ±rÄ±lmalÄ±dÄ±r.

ğŸ‘‹ HTML Nesnelerinde TagHelper KullanÄ±mÄ± 

âœ¨ Form TagHelper âœ¨

![22-2](https://github.com/user-attachments/assets/4edb9d51-b49f-46ca-8033-55f0a74d2888)

![22-4](https://github.com/user-attachments/assets/e08dc8bb-a614-4665-8496-fae3eca2c989)

ğŸ‘‰ ! TagHelper'Ä±n aktif olup olmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in, bir HTML nesnesi Ã¼zerine gelip asp yazdÄ±ÄŸÄ±nÄ±zda, eÄŸer ki @asp Ã§Ä±kÄ±yorsa, kÃ¼tÃ¼phane doÄŸru yazÄ±lmÄ±ÅŸ ve TagHelper kullanÄ±lÄ±yor demektir. 

![22-3](https://github.com/user-attachments/assets/75baf373-9af7-4590-828a-929d64a3a0e8)

âœ¨ Input TagHelper âœ¨

Input nesnelerinde kullanabildiÄŸimiz, bu nesneler Ã¼zerinde belirli model binding iÅŸlemlerinde vs. kullandÄ±ÄŸÄ±mÄ±z TagHelper'lardÄ±r.

![22-5](https://github.com/user-attachments/assets/5fb0dee3-7143-46af-b2e0-60933e044ce2)


âœ¨ Cache TagHelper âœ¨

![22-6](https://github.com/user-attachments/assets/4ec48d3b-e67b-4083-b9a0-81084312fd87)

![22-7](https://github.com/user-attachments/assets/ac9ba10a-3549-41df-859f-eb7f5b4eb576)

InMemory'de cache'lenir.
SayfayÄ± her yenilediÄŸimizde, cache tag'li olan kÄ±sÄ±m cache'den gelir ve yenilenmez.
Ancak diÄŸer kullanÄ±mda dikkat edilirse, saliseli kÄ±sÄ±m deÄŸiÅŸiyor.

âœ¨ Environment TagHelper âœ¨

![22-8](https://github.com/user-attachments/assets/7d2913f3-831b-4d06-a3d1-6a3213738e4e)


âœ¨ Image TagHelper ve ETag KullanÄ±mÄ± âœ¨


Image TagHelper, ETag yÃ¶ntemini otomatik olarak kullanmamÄ±zÄ± saÄŸlar.

ETag (Entity Tag), bir jeton (token) oluÅŸturarak statik dosyalarda deÄŸiÅŸiklik olup olmadÄ±ÄŸÄ±nÄ± belirler.

âœ” EÄŸer bir statik dosyada deÄŸiÅŸiklik yoksa, istemciye yeniden indirme yapmadan mevcut Ã¶nbellekteki sÃ¼rÃ¼mÃ¼ kullanmasÄ±nÄ± sÃ¶yler.

âœ” Bu sayede gereksiz veri transferi Ã¶nlenir ve performans artÄ±rÄ±lÄ±r.

ğŸ”¹ Yani, ETag sayesinde statik dosyalarda deÄŸiÅŸiklik olmadÄ±kÃ§a istemciye aynÄ± dosya tekrar gÃ¶nderilmez.

ğŸ”¹ EÄŸer kaynakta bulunan statik dosya deÄŸiÅŸirse, ETag deÄŸeri de deÄŸiÅŸir.

ğŸ”¹ Bu durumda, istemcinin Ã¶nbelleÄŸinde bulunan eski dosya artÄ±k geÃ§erli olmaz.

ğŸ”¹ Sunucu, yeni dosyanÄ±n gÃ¼ncellenmiÅŸ halini istemciye gÃ¶nderir.


âœ… Bu sayede, Ã¶nbelleÄŸe alÄ±nmÄ±ÅŸ eski iÃ§erik yerine en gÃ¼ncel versiyon otomatik olarak kullanÄ±lÄ±r.

Ã–zet:

ğŸ“Œ Cache'deki dosya, kaynakta deÄŸiÅŸtiyse, Ã¶nbellekteki eski sÃ¼rÃ¼m silinir ve size gerÃ§ek (gÃ¼ncellenmiÅŸ) dosya teslim edilir.

ğŸ‘‰ ! ASP.NET Core'da Tag Helper kullanÄ±rsan, Image Tag Helper otomatik olarak ETag yÃ¶netimini yapar. Ancak, HTML Helper kullanÄ±yorsan, dosyanÄ±n deÄŸiÅŸip deÄŸiÅŸmediÄŸini manuel olarak kontrol edip, gerekirse yeni sÃ¼rÃ¼mÃ¼nÃ¼ yÃ¼klemen gerekir.


âœ¨  Partial TagHelper  âœ¨

![22-9](https://github.com/user-attachments/assets/f76d2b9d-01a6-4952-82da-95a51f7ea57c)

ğŸ‘‰ ! TagHelper'larÄ± EklediÄŸimiz View'lerden Tekrar KaldÄ±rabiliriz

![22-10](https://github.com/user-attachments/assets/0de0bf0b-e0f1-467a-a470-2c4cbcf858e1)

![22-11](https://github.com/user-attachments/assets/98269001-bf1b-491b-bd92-1cf22fed4eaa)


ğŸ“Œ Ä°leride gÃ¶receÄŸimiz ViewImport.cshtml adÄ±nda bir dosyamÄ±z olacak ve bu dosyada tanÄ±mladÄ±ÄŸÄ±mÄ±z using direktifleri veya belirli kÃ¼tÃ¼phaneler tÃ¼m view'lar tarafÄ±ndan eriÅŸilebilir olacak. DolayÄ±sÄ±yla, TagHelper'Ä± da burada tanÄ±mlayacaÄŸÄ±z. Bu sayede, tek tek gidip tÃ¼m view'larda tanÄ±mlamak zorunda kalmayacaÄŸÄ±z. Ancak, bazÄ± view'lerde TagHelper kullanmak istemeyebiliriz. Bunun iÃ§in ilgili view'de @remove TagHelper kullanarak, yalnÄ±zca o sayfa iÃ§in TagHelper'Ä± pasifleÅŸtirebiliriz.










